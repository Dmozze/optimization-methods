\chapter{Методы многомерной оптимизации}


\section{Постановка задачи и цель работы}

\begin{enumerate}
    \item Реализовать алгоритмы:
    \begin{itemize}
        \item 	Метод градиентного спуска
        \item   Метод наискорейшего спуска
        \item   Метод сопряженных градиентов
    \end{itemize}
    Оценить как меняется скорость сходимости, если для поиска величины шага используются
    различные методы одномерного поиска.
    \item Проанализировать траектории методов для нескольких квадратичных
    функций: придумайте две-три квадратичные двумерные функции, на которых
    работа каждого из методов будет отличаться. Нарисовать графики с линиями
    уровня функций и траекториями методов.
    \item Исследовать, как зависит число итераций, необходимое методам для
    сходимости, от следующих двух параметров:
    \begin{itemize}
        \item числа обусловленности $k \geq 1$ оптимизируемой функции
        \item размерности пространства $n$ оптимизируемых переменных
    \end{itemize}
    Сгенерировать от заданных параметров $k$ и $n$ квадратичную задачу размерности $n$ с числом обусловленности
    $k$ и запустить на ней методы многомерной оптимизации с некоторой заданной точностью. Замерить число итераций $T(n, k)$, которое 
    потребовалось сделать методу до сходимости.
\end{enumerate}



\section{Иллуюстрации работы градиентных методов на двумерных квадратичных функцкиях}

Рассмотрим функцию $f(x, y) = x^2 - xy + 4y^2 + 2x + y$. В матричном виде ее вид 
$f(x) = 1/2 * (Ax, x) + b * x$, где $A = $
\begin{pmatrix}
    2 & -1\\
    -1 & 8
\end{pmatrix}
и $b = $
\begin{pmatrix}
    2 \\
    1
\end{pmatrix}.

$det(A - \lambda E) = $
\begin{vmatrix}
    2 - \lambda & -1\\
    -1 & 8 - \lambda
\end{vmatrix}
$ = (2 - \lambda) * (8 - \lambda) - 1 = 15 - 10 * \lambda + \lambda^2 = (5 + \sqrt{10} - \lambda) * (5 + \sqrt{10} - \lambda)$.
Собственные значение матрицы $A$ положительны, следовательно квадратичная форма $f$ положительно определенная, а 
следовательно выпукла вниз. Таким образом к этой квадратчной форме можно применить алгоритмы минимизации.
Для начала найдем точку минимума функции аналитически.


Надем точку, в которой градиент данной функции обращается в ноль. Это и будет точка минимума функции.
$grad\ f = $
\begin{pmatrix}
    2 * x - y + 2 & -x + 8y + 1
\end{pmatrix}$^T = (0\ 0)^T$.
Решив систему линейных уравнений, получаем $x = -17/15, y = -4/15$ и $min(f(x, y)) = -19/15$


\section{Общая схема того, как мы реализовывали алгоритмы}

В начале мы создали классы Matrix, DiagonalMatix и Vector и для них перегрузили операторы $'+'$, $'-'$, $'*'$ и $'[\ ]'$
 (класс DiagonalMatix появился только под конец, когда мы уже начали тестировать и узнали, что для тестов нужны только 
 диагональные матрицы и оказалось, что в коде для матриц испльзовался только оператор $'*'$, поэтому мы не стали реализовывать остальные 
 перегрузки для этого класса).

 Далее мы решили не использовать лямда-функции для задания квадратичных форм, а сделать отдельные классы
QuadraticFunction и \newline DiagonalQuadraticFunction, в которых храниться матрица $A$, вектор $b$ и число $c$, и просто
передавать их в качестве параметров в реализуемые алгоритмы, к тому же в классе можно хранить всю историю
 обращения к функции, что мы и делали.

Также мы создали класс GeneratorQudraticFunction, который генерировал рандомые
 вектора по заданной размерности и числу обусловленности.

 Пример того, как выглядели наши сгенерированные функции:
\newline

\texttt{\small 1 38.0198 208.636 276.712 419.618 517.318 549.321 565.029 598.464 641 }

\texttt{\small 1 56.0696 86.0772 94.8904 129.966 133.73 151.615 295.072 304.457 330.866 }

\texttt{\small 1 121.07 250.754 316.186 452.644 463.517 492.598 526.129 690.467 706.2} 
\newline

Первая строчка это диагональная матрица $A$. В данном случае с числом обусловленноости $641$.
Вторая строчка это вектор $b$. Прибавление константы мы решили не генерировать, так как на поиск точки
минимума она не влияет. Третья строка это начальное приближение $x_0$. 

Все сгенерированные функции мы сохраняли в файлы,
и благодаря этому не приходилось заново генерировать функции для каждого запуска программы, а также была
возможность запускать тестирование на каждом методе отдельно. 

Точность для алгоритмов мы решили задать всего лишь $0.01$, так как при тестировании не хотелось ждать по 30 минут, пока
алгоритмы найдут необходимый минимум для всех сгенерированных функций. Да и это не требовалось, так как судя по
данным, которые мы получали, этой точности хватало, чтобы получать приближение до пяти знаков после запятой.
 Также при вычислении минимума 
у функции размерности
$n = 10^4$ пришлось ограничится числом обусловленности до $k = 1000$, так как наши алгоритмы работали очень долго.





\section{Метод градиентного спуска}

Заметим, что в методе градиентного спуска константа линейной скорости сходимости $q = 2/(l + L)$ не зависит
от размерности пространства $n$, а только от собственных чисел матрицы $A$ квадратичной формы, а следовательно
для всех размерностей должны получится схожие результаты, что мы как раз таки видим на графике ниже.
Но есть несколько минимумов, которые выбиваются из общей массы.
 Скорее всего это из-за того, что сгенерированная
точка попала в многомерный овраг и из-за этого не происходило сильных биений. По сгенерированным
тестам это сложно понять.



\begin{flushleft}
    \begin{tikzpicture}
        \begin{axis}[
            table/col sep = semicolon,
            xlabel = {$k$},
            ylabel = {$times$},
            height = 0.4\paperheight,
            width = 0.8\paperwidth,
            /pgf/number format/1000 sep={},
            legend pos={north west},
            grid=major,
        ]
        
        \legend{
            $n = 10$,
            $n = 10^2$,
            $n = 10^3$,
            $n = 10^4$,
        };

        \addplot table [x={k}, y={times}]
                  {descent/10k.csv};
        \addplot table [x={k}, y={times}]
                  {descent/100k.csv};
        \addplot table [x={k}, y={times}]
                  {descent/1000k.csv};
        \addplot table [x={k}, y={times}]
                  {descent/10000k.csv};
        \end{axis}
    \end{tikzpicture}
\end{flushleft}


\begin{flushleft}
    \begin{tikzpicture}
        \begin{axis}[
            table/col sep = semicolon,
            xlabel = {$n$},
            ylabel = {$times$},
            height = 0.4\paperheight,
            width = 0.8\paperwidth,
            /pgf/number format/1000 sep={},
            legend pos={north west},
            grid=major,
        ]
        
        \addplot table [x={n}, y={times}]
                      {descent/n_good.csv};
        \end{axis}
    \end{tikzpicture}
\end{flushleft}

\section{Метод наискорейшего спуска}

\begin{flushleft}
    \begin{tikzpicture}
        \begin{axis}[
            table/col sep = semicolon,
            xlabel = {$k$},
            ylabel = {$times$},
            height = 0.6\paperheight,
            width = 0.8\paperwidth,
            /pgf/number format/1000 sep={},
            legend pos={north west}
        ]
        
        \legend{
            $n = 10$,
            $n = 10^2$,
            $n = 10^3$,
            $n = 10^4$,
        };

        \addplot table [x={k}, y={times}]
                  {steepest/10k.csv};
        \addplot table [x={k}, y={times}]
                  {steepest/100k.csv};
        \addplot table [x={k}, y={times}]
                  {steepest/1000k.csv};
        \addplot table [x={k}, y={times}]
                  {steepest/10000k.csv};
        \end{axis}
    \end{tikzpicture}
\end{flushleft}


\begin{flushleft}
    \begin{tikzpicture}
        \begin{axis}[
            table/col sep = semicolon,
            xlabel = {$n$},
            ylabel = {$times$},
            height = 0.6\paperheight,
            width = 0.8\paperwidth,
            /pgf/number format/1000 sep={},
            legend pos={north west},
            grid=major,
        ]
        
        \addplot table [x={n}, y={times}]
                      {steepest/n_good.csv};
        \end{axis}
    \end{tikzpicture}
\end{flushleft}

\section{Метод сопряженных градиентов}


\begin{flushleft}
    \begin{tikzpicture}
        \begin{axis}[
            table/col sep = semicolon,
            xlabel = {$k$},
            ylabel = {$times$},
            height = 0.6\paperheight,
            width = 0.8\paperwidth,
            /pgf/number format/1000 sep={},
            legend pos={north west},
            grid=major,
        ]
        
        \legend{
            $n = 10$,
            $n = 10^2$,
            $n = 10^3$,
            $n = 10^4$,
        };

        \addplot table [x={k}, y={times}]
                  {conjugate/10k.csv};
        \addplot table [x={k}, y={times}]
                  {conjugate/100k.csv};
        \addplot table [x={k}, y={times}]
                  {conjugate/1000k.csv};
        \addplot table [x={k}, y={times}]
                  {conjugate/10000k.csv};
        \end{axis}
    \end{tikzpicture}
\end{flushleft}


\begin{flushleft}
    \begin{tikzpicture}
        \begin{axis}[
            table/col sep = semicolon,
            xlabel = {$n$},
            ylabel = {$times$},
            height = 0.6\paperheight,
            width = 0.8\paperwidth,
            /pgf/number format/1000 sep={},
            legend pos={north west},
            grid=major,
        ]
        
        \addplot table [x={n}, y={times}]
                      {conjugate/n_good.csv};
        \end{axis}
    \end{tikzpicture}
\end{flushleft}
